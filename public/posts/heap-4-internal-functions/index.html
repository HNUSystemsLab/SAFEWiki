<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My First Post | new new new test</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="internal function 这是内部使用的一些常用函数的列表。要注意的是，某些函数实际上是使用 #define 指令定义的。因此，对调用参数的更改实际上在调用操作之后会保留。然后假定没有设置MALLOC_DEBUG。
arena_get (ar_ptr, size) 首先获取一块区域然后把相对应的互斥锁锁住。然后ar_ptr指针指向相应的区域。Size参数只是表明要占用多少内存。
Sysmalloc [TODO] Sysmalloc需要系统用malloc函数分配更多的内存 在使用的时候假设av-&gt;top的空间并不够请求nb字节，因此需要延长或者替换av-&gt;top.
void alloc_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与perturb_byte ^ 0xff相等。
void free_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与 perturb_byte相等。
void malloc_init_state (mstate av) 初始化malloc_state结构。这仅从内部调用malloc_consolidate函数（malloc_consolidate需要在相同环境被调用）它从不在 malloc _ merge之外直接调用，因为一些编译器试图在所有调用点对他进行内联操作，反而造成了负优化的后果。（虽然将它内联在malloc_consolidate中很棒就是了） 1.对于不是fastbin的bins来说，需要为每个bin创建一个空循环链表 2.为av 设置FASTCHUNKS_BIT的flag参数 3.把av-&gt;top初始化为第一个未经过排序的chunk
unlink(AV, P, BK, FD) 定义一个宏指令从而从bin中删除一个chunk 1.检查chunk的大小是否和下一个chunk里之前设置的大小相等，否则的话将显示&quot;corrupted size vs. prev_size&quot;错误 2.">
    <meta name="generator" content="Hugo 0.110.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="My First Post" />
<meta property="og:description" content="internal function 这是内部使用的一些常用函数的列表。要注意的是，某些函数实际上是使用 #define 指令定义的。因此，对调用参数的更改实际上在调用操作之后会保留。然后假定没有设置MALLOC_DEBUG。
arena_get (ar_ptr, size) 首先获取一块区域然后把相对应的互斥锁锁住。然后ar_ptr指针指向相应的区域。Size参数只是表明要占用多少内存。
Sysmalloc [TODO] Sysmalloc需要系统用malloc函数分配更多的内存 在使用的时候假设av-&gt;top的空间并不够请求nb字节，因此需要延长或者替换av-&gt;top.
void alloc_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与perturb_byte ^ 0xff相等。
void free_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与 perturb_byte相等。
void malloc_init_state (mstate av) 初始化malloc_state结构。这仅从内部调用malloc_consolidate函数（malloc_consolidate需要在相同环境被调用）它从不在 malloc _ merge之外直接调用，因为一些编译器试图在所有调用点对他进行内联操作，反而造成了负优化的后果。（虽然将它内联在malloc_consolidate中很棒就是了） 1.对于不是fastbin的bins来说，需要为每个bin创建一个空循环链表 2.为av 设置FASTCHUNKS_BIT的flag参数 3.把av-&gt;top初始化为第一个未经过排序的chunk
unlink(AV, P, BK, FD) 定义一个宏指令从而从bin中删除一个chunk 1.检查chunk的大小是否和下一个chunk里之前设置的大小相等，否则的话将显示&quot;corrupted size vs. prev_size&quot;错误 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/heap-4-internal-functions/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-05T15:36:08+08:00" />
<meta property="article:modified_time" content="2023-02-05T15:36:08+08:00" />
<meta itemprop="name" content="My First Post">
<meta itemprop="description" content="internal function 这是内部使用的一些常用函数的列表。要注意的是，某些函数实际上是使用 #define 指令定义的。因此，对调用参数的更改实际上在调用操作之后会保留。然后假定没有设置MALLOC_DEBUG。
arena_get (ar_ptr, size) 首先获取一块区域然后把相对应的互斥锁锁住。然后ar_ptr指针指向相应的区域。Size参数只是表明要占用多少内存。
Sysmalloc [TODO] Sysmalloc需要系统用malloc函数分配更多的内存 在使用的时候假设av-&gt;top的空间并不够请求nb字节，因此需要延长或者替换av-&gt;top.
void alloc_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与perturb_byte ^ 0xff相等。
void free_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与 perturb_byte相等。
void malloc_init_state (mstate av) 初始化malloc_state结构。这仅从内部调用malloc_consolidate函数（malloc_consolidate需要在相同环境被调用）它从不在 malloc _ merge之外直接调用，因为一些编译器试图在所有调用点对他进行内联操作，反而造成了负优化的后果。（虽然将它内联在malloc_consolidate中很棒就是了） 1.对于不是fastbin的bins来说，需要为每个bin创建一个空循环链表 2.为av 设置FASTCHUNKS_BIT的flag参数 3.把av-&gt;top初始化为第一个未经过排序的chunk
unlink(AV, P, BK, FD) 定义一个宏指令从而从bin中删除一个chunk 1.检查chunk的大小是否和下一个chunk里之前设置的大小相等，否则的话将显示&quot;corrupted size vs. prev_size&quot;错误 2."><meta itemprop="datePublished" content="2023-02-05T15:36:08+08:00" />
<meta itemprop="dateModified" content="2023-02-05T15:36:08+08:00" />
<meta itemprop="wordCount" content="110">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My First Post"/>
<meta name="twitter:description" content="internal function 这是内部使用的一些常用函数的列表。要注意的是，某些函数实际上是使用 #define 指令定义的。因此，对调用参数的更改实际上在调用操作之后会保留。然后假定没有设置MALLOC_DEBUG。
arena_get (ar_ptr, size) 首先获取一块区域然后把相对应的互斥锁锁住。然后ar_ptr指针指向相应的区域。Size参数只是表明要占用多少内存。
Sysmalloc [TODO] Sysmalloc需要系统用malloc函数分配更多的内存 在使用的时候假设av-&gt;top的空间并不够请求nb字节，因此需要延长或者替换av-&gt;top.
void alloc_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与perturb_byte ^ 0xff相等。
void free_perturb (char *p, size_t n) 如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与 perturb_byte相等。
void malloc_init_state (mstate av) 初始化malloc_state结构。这仅从内部调用malloc_consolidate函数（malloc_consolidate需要在相同环境被调用）它从不在 malloc _ merge之外直接调用，因为一些编译器试图在所有调用点对他进行内联操作，反而造成了负优化的后果。（虽然将它内联在malloc_consolidate中很棒就是了） 1.对于不是fastbin的bins来说，需要为每个bin创建一个空循环链表 2.为av 设置FASTCHUNKS_BIT的flag参数 3.把av-&gt;top初始化为第一个未经过排序的chunk
unlink(AV, P, BK, FD) 定义一个宏指令从而从bin中删除一个chunk 1.检查chunk的大小是否和下一个chunk里之前设置的大小相等，否则的话将显示&quot;corrupted size vs. prev_size&quot;错误 2."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        new new new test
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">My First Post</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-02-05T15:36:08+08:00">February 5, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="internal-function">internal function</h1>
<p>这是内部使用的一些常用函数的列表。要注意的是，某些函数实际上是使用 #define 指令定义的。因此，对调用参数的更改实际上在调用操作之后会保留。然后假定没有设置MALLOC_DEBUG。</p>
<h2 id="arena_get-ar_ptr-size">arena_get (ar_ptr, size)</h2>
<p>首先获取一块区域然后把相对应的互斥锁锁住。然后ar_ptr指针指向相应的区域。Size参数只是表明要占用多少内存。</p>
<h2 id="sysmalloc-todo">Sysmalloc [TODO]</h2>
<p>Sysmalloc需要系统用malloc函数分配更多的内存
在使用的时候假设av-&gt;top的空间并不够请求nb字节，因此需要延长或者替换av-&gt;top.</p>
<h2 id="void-alloc_perturb-char-p-size_t-n">void alloc_perturb (char *p, size_t n)</h2>
<p>如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与perturb_byte ^ 0xff相等。</p>
<h2 id="void-free_perturb-char-p-size_t-n">void free_perturb (char *p, size_t n)</h2>
<p>如果 perturb_byte（使用 M_PERTURB 的 malloc 的可调参数）不为零（默认情况下为 0），则修改 p 指向的 n 个字节的内容，使其与 perturb_byte相等。</p>
<h2 id="void-malloc_init_state-mstate-av">void malloc_init_state (mstate av)</h2>
<p>初始化malloc_state结构。这仅从内部调用malloc_consolidate函数（malloc_consolidate需要在相同环境被调用）它从不在 malloc _ merge之外直接调用，因为一些编译器试图在所有调用点对他进行内联操作，反而造成了负优化的后果。（虽然将它内联在malloc_consolidate中很棒就是了）
1.对于不是fastbin的bins来说，需要为每个bin创建一个空循环链表
2.为av 设置FASTCHUNKS_BIT的flag参数
3.把av-&gt;top初始化为第一个未经过排序的chunk</p>
<h2 id="unlinkav-p-bk-fd">unlink(AV, P, BK, FD)</h2>
<p>定义一个宏指令从而从bin中删除一个chunk
1.检查chunk的大小是否和下一个chunk里之前设置的大小相等，否则的话将显示&quot;corrupted size vs. prev_size&quot;错误
2.检查P-&gt;fd-&gt;bk是否和P相等和P-&gt;bk-&gt;fd是否和P相等，否则的话将显示&quot;corrupted double-linked list&quot;错误
3.调整列表中的相邻chunk的前后指针以便删除
1.设置P-&gt;fd-&gt;bk = P-&gt;bk
2.设置P-&gt;bk-&gt;fd = P-&gt;fd</p>
<h2 id="void-malloc_consolidatemstate-av">void malloc_consolidate(mstate av)</h2>
<p>free函数的特殊版本。
1.在av未被初始化的条件下检查global_max_fast是否为0，如果为 0，则以 av 作为参数调用 malloc_init_state 并返回。
2. 如果global_max_fast不为0，清除 av 的FASTCHUNKS_BIT flag。
3. 从第一个索引迭代 fastbin 数组到最后一个索引：
1）锁住当前的fastbin chunk 并且如果它不是空的话便继续。
2）如果未使用上一个内存块，调用上一个块上的unlink函数
3）如果下一个内存块不是在最顶部：
1））如果下一个内存块没有被使用，则为下一个内存块调用unlink函数
2））如果其中任意一个内存块是空的话，则将上下内存块合并，然后将合并之后的内存块放到为排序的bin的头部
4）如果下一个内存块在顶部，把所有在顶部空的内存块合并为一个内存块
注意：使用PREV_IN_USE来检查该内存块是否被使用，这样的话其他的fastbin chunk就不会被标志为空闲。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  new new new test 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
